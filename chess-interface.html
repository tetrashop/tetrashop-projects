
    <!DOCTYPE html>
    <html style="height:100%;">
    <head>
<link rel="stylesheet" href="/style.css">
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Ø´Ø·Ø±Ù†Ø¬ Ù‡ÙˆØ´Ù…Ù†Ø¯</title>
        <style>
            body {
                font-family: Tahoma, sans-serif;
                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                color: white;
                margin: 0;
                padding: 20px;
                text-align: center;
            }
            .chess-container {
                max-width: 600px;
                margin: 0 auto;
                background: rgba(255,255,255,0.1);
                padding: 30px;
                border-radius: 20px;
                border: 1px solid rgba(255,255,255,0.2);
            }
            .chess-board {
                display: grid;
                grid-template-columns: repeat(8, 60px);
                grid-template-rows: repeat(8, 60px);
                gap: 2px;
                background: #769656;
                padding: 10px;
                border-radius: 10px;
                margin: 20px auto;
                width: fit-content;
            }
            .chess-square {
                width: 60px;
                height: 60px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 2rem;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            .chess-square.light {
                background: #eeeed2;
            }
            .chess-square.dark {
                background: #769656;
            }
            .chess-square:hover {
                background: #b5c7a3;
                transform: scale(1.1);
            }
            .chess-square.selected {
                background: #ffeb3b;
            }
            .chess-square.valid-move {
                background: #90ee90;
            }
            .btn {
                padding: 12px 25px;
                background: #2563eb;
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 1rem;
                margin: 10px;
                transition: all 0.3s ease;
            }
            .btn:hover {
                background: #7c3aed;
                transform: translateY(-2px);
            }
            .status {
                margin: 20px 0;
                padding: 15px;
                background: rgba(255,255,255,0.1);
                border-radius: 10px;
                font-size: 1.1rem;
            }
        </style>
    </head>
    <body style="margin:0;padding:0;min-height:100vh;">
        <div class="chess-container">
            <h1>â™Ÿï¸ Ø´Ø·Ø±Ù†Ø¬ Ù‡ÙˆØ´Ù…Ù†Ø¯</h1>
            <p>Ø³ÛŒØ³ØªÙ… Ø´Ø·Ø±Ù†Ø¬ Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª Ø­Ø±Ú©Øª ÙˆØ§Ù‚Ø¹ÛŒ</p>
            
            <div class="status" id="status">Ù†ÙˆØ¨Øª: Ø³ÙÛŒØ¯ - Ø¨Ø§Ø²ÛŒ Ø±Ø§ Ø´Ø±ÙˆØ¹ Ú©Ù†ÛŒØ¯</div>
            
            <div class="chess-board" id="chessBoard">
                <!-- Board will be generated by JavaScript -->
            </div>
            
            <div>
                <button class="btn" onclick="startNewGame()">ğŸ”„ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯</button>
                <button class="btn" onclick="makeAIMove()">ğŸ¤– Ø­Ø±Ú©Øª Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</button>
                <button class="btn" onclick="suggestMove()">ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø­Ø±Ú©Øª</button>
            </div>
            
            <div style="margin-top: 20px;">
                <button class="btn" onclick="window.close()">Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø³ÛŒØ³ØªÙ… Ø§ØµÙ„ÛŒ</button>
            </div>
        </div>

        <script>
            let currentGame = {
                board: [],
                currentPlayer: 'white',
                selectedPiece: null,
                validMoves: []
            };

            const pieceMapping = {
                'white': {
                    'pawn': 'â™™', 'rook': 'â™–', 'knight': 'â™˜', 
                    'bishop': 'â™—', 'queen': 'â™•', 'king': 'â™”'
                },
                'black': {
                    'pawn': 'â™Ÿ', 'rook': 'â™œ', 'knight': 'â™',
                    'bishop': 'â™', 'queen': 'â™›', 'king': 'â™š'
                }
            };

            function initializeBoard() {
                const board = [];
                
                // Initialize empty board
                for (let row = 0; row < 8; row++) {
                    board[row] = [];
                    for (let col = 0; col < 8; col++) {
                        board[row][col] = null;
                    }
                }
                
                // Setup pawns
                for (let col = 0; col < 8; col++) {
                    board[1][col] = { type: 'pawn', color: 'black' };
                    board[6][col] = { type: 'pawn', color: 'white' };
                }
                
                // Setup other pieces
                const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                for (let col = 0; col < 8; col++) {
                    board[0][col] = { type: backRow[col], color: 'black' };
                    board[7][col] = { type: backRow[col], color: 'white' };
                }
                
                return board;
            }

            function renderBoard() {
                const boardElement = document.getElementById('chessBoard');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        const piece = currentGame.board[row][col];
                        if (piece) {
                            square.textContent = pieceMapping[piece.color][piece.type];
                            square.style.color = piece.color === 'white' ? 'white' : 'black';
                        }
                        
                        // Highlight selected piece and valid moves
                        if (currentGame.selectedPiece && 
                            currentGame.selectedPiece.row === row && 
                            currentGame.selectedPiece.col === col) {
                            square.classList.add('selected');
                        }
                        
                        if (currentGame.validMoves.some(move => move.row === row && move.col === col)) {
                            square.classList.add('valid-move');
                        }
                        
                        square.onclick = () => handleSquareClick(row, col);
                        boardElement.appendChild(square);
                    }
                }
            }

            function handleSquareClick(row, col) {
                const piece = currentGame.board[row][col];
                
                // If a piece is already selected
                if (currentGame.selectedPiece) {
                    const moveIsValid = currentGame.validMoves.some(
                        move => move.row === row && move.col === col
                    );
                    
                    if (moveIsValid) {
                        // Make the move
                        makeMove(currentGame.selectedPiece.row, currentGame.selectedPiece.col, row, col);
                        return;
                    }
                    
                    // Deselect if clicking on same piece or invalid move
                    currentGame.selectedPiece = null;
                    currentGame.validMoves = [];
                    renderBoard();
                }
                
                // Select a new piece if it belongs to current player
                if (piece && piece.color === currentGame.currentPlayer) {
                    currentGame.selectedPiece = { row, col, piece };
                    currentGame.validMoves = calculateValidMoves(row, col, piece);
                    renderBoard();
                }
            }

            function calculateValidMoves(row, col, piece) {
                const moves = [];
                
                // Basic movement patterns (simplified)
                if (piece.type === 'pawn') {
                    const direction = piece.color === 'white' ? -1 : 1;
                    
                    // Forward move
                    if (!currentGame.board[row + direction][col]) {
                        moves.push({ row: row + direction, col: col });
                        
                        // Double move from starting position
                        if ((piece.color === 'white' && row === 6) || 
                            (piece.color === 'black' && row === 1)) {
                            if (!currentGame.board[row + 2 * direction][col]) {
                                moves.push({ row: row + 2 * direction, col: col });
                            }
                        }
                    }
                }
                
                // Add more piece movement logic here...
                
                return moves.filter(move => 
                    move.row >= 0 && move.row < 8 && move.col >= 0 && move.col < 8
                );
            }

            function makeMove(fromRow, fromCol, toRow, toCol) {
                // Move the piece
                currentGame.board[toRow][toCol] = currentGame.board[fromRow][fromCol];
                currentGame.board[fromRow][fromCol] = null;
                
                // Switch player
                currentGame.currentPlayer = currentGame.currentPlayer === 'white' ? 'black' : 'white';
                currentGame.selectedPiece = null;
                currentGame.validMoves = [];
                
                updateStatus();
                renderBoard();
            }

            function startNewGame() {
                currentGame.board = initializeBoard();
                currentGame.currentPlayer = 'white';
                currentGame.selectedPiece = null;
                currentGame.validMoves = [];
                
                updateStatus();
                renderBoard();
            }

            function makeAIMove() {
                document.getElementById('status').textContent = 'ğŸ¤– Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¯Ø± Ø­Ø§Ù„ ÙÚ©Ø± Ú©Ø±Ø¯Ù†...';
                
                setTimeout(() => {
                    // Find a random valid move for AI
                    const aiPieces = [];
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            const piece = currentGame.board[row][col];
                            if (piece && piece.color === currentGame.currentPlayer) {
                                const moves = calculateValidMoves(row, col, piece);
                                if (moves.length > 0) {
                                    aiPieces.push({ row, col, moves });
                                }
                            }
                        }
                    }
                    
                    if (aiPieces.length > 0) {
                        const randomPiece = aiPieces[Math.floor(Math.random() * aiPieces.length)];
                        const randomMove = randomPiece.moves[Math.floor(Math.random() * randomPiece.moves.length)];
                        makeMove(randomPiece.row, randomPiece.col, randomMove.row, randomMove.col);
                    }
                }, 1000);
            }

            function suggestMove() {
                const status = document.getElementById('status');
                status.textContent = 'ğŸ’¡ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯: ÛŒÚ© Ù…Ù‡Ø±Ù‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ø§Ø² Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ú©Ù…Ú© Ø¨Ú¯ÛŒØ±ÛŒØ¯';
                
                setTimeout(() => {
                    updateStatus();
                }, 3000);
            }

            function updateStatus() {
                const status = document.getElementById('status');
                const playerName = currentGame.currentPlayer === 'white' ? 'Ø³ÙÛŒØ¯' : 'Ø³ÛŒØ§Ù‡';
                status.textContent = `Ù†ÙˆØ¨Øª: ${playerName} - Ø¨Ø§Ø²ÛŒ Ø¯Ø± Ø¬Ø±ÛŒØ§Ù†`;
            }

            // Initialize the game
            document.addEventListener('DOMContentLoaded', function() {
                startNewGame();
            });
        </script>
    </body>
    </html>
    