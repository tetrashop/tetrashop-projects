<!DOCTYPE html>
<html dir="ltr" lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloud Chess Engine - Tetrashop</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            margin-top: 20px;
        }
        
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 70px);
            grid-template-rows: repeat(8, 70px);
            border: 4px solid #8B4513;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .square.light { background: #F0D9B5; }
        .square.dark { background: #B58863; }
        
        .square.selected { 
            background: #90EE90 !important;
            box-shadow: inset 0 0 0 3px #32CD32;
        }
        
        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(0, 255, 0, 0.3);
            border-radius: 50%;
        }
        
        .square.attack-move::after {
            content: '';
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 0, 0, 0.5);
            border-radius: 50%;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .status {
            margin-bottom: 20px;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
        }
        
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #2563eb;
        }
        
        button:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }
        
        .move-history {
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .move-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .status-connected { background: #10b981; }
        .status-disconnected { background: #ef4444; }
        .status-connecting { background: #f59e0b; animation: pulse 1.5s infinite; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
            .chess-board {
                grid-template-columns: repeat(8, 45px);
                grid-template-rows: repeat(8, 45px);
            }
            .square {
                font-size: 30px;
            }
        }
    </style>
</head>
<body>
    <h1>‚ôüÔ∏è Cloud Chess Engine - Tetrashop</h1>
    <p>Play against AI powered by distributed cloud computing</p>
    
    <div class="container">
        <div class="chess-board" id="chessBoard">
            <!-- Board will be generated by JavaScript -->
        </div>
        
        <div class="panel">
            <div class="connection-status">
                <div class="status-dot status-connecting" id="statusDot"></div>
                <span id="statusText">Connecting to Cloud Server...</span>
            </div>
            
            <div class="status">
                <h3>Game Status</h3>
                <p id="gameStatus">Setting up game...</p>
                <p id="currentPlayer">Current: White</p>
            </div>
            
            <div class="controls">
                <button onclick="newGame()">üîÑ New Game</button>
                <button onclick="undoMove()">‚Ü©Ô∏è Undo</button>
                <button onclick="switchSide()">üîÑ Switch Side</button>
                <button onclick="showHint()">üí° Hint</button>
            </div>
            
            <div class="difficulty">
                <h3>AI Difficulty</h3>
                <select id="difficulty" onchange="changeDifficulty()">
                    <option value="1">Easy (Depth 2)</option>
                    <option value="2" selected>Medium (Depth 3)</option>
                    <option value="3">Hard (Depth 4)</option>
                    <option value="4">Expert (Depth 5)</option>
                </select>
            </div>
            
            <div class="move-history">
                <h3>Move History</h3>
                <div id="moveList"></div>
            </div>
        </div>
    </div>

    <script>
        // Ÿàÿ∂ÿπ€åÿ™ ÿ®ÿßÿ≤€å
        let gameState = {
            board: [],
            selectedPiece: null,
            validMoves: [],
            currentPlayer: 'white',
            moveHistory: [],
            playerColor: 'white',
            connected: false,
            gameActive: false
        };

        // ŸÜŸÖÿßÿØŸáÿß€å Unicode ÿ®ÿ±ÿß€å ŸÖŸáÿ±Ÿá‚ÄåŸáÿß
        const pieceSymbols = {
            'white': {
                'king': '‚ôî', 'queen': '‚ôï', 'rook': '‚ôñ',
                'bishop': '‚ôó', 'knight': '‚ôò', 'pawn': '‚ôô'
            },
            'black': {
                'king': '‚ôö', 'queen': '‚ôõ', 'rook': '‚ôú',
                'bishop': '‚ôù', 'knight': '‚ôû', 'pawn': '‚ôü'
            }
        };

        // ŸÖŸÇÿØÿßÿ±ÿØŸá€å ÿßŸàŸÑ€åŸá ÿµŸÅÿ≠Ÿá
        function initializeBoard() {
            const board = document.getElementById('chessBoard');
            board.innerHTML = '';
            
            for (let row = 7; row >= 0; row--) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    
                    board.appendChild(square);
                }
            }
            
            setupInitialPosition();
        }

        // ÿ™ŸÜÿ∏€åŸÖ ŸÖŸàŸÇÿπ€åÿ™ ÿßŸàŸÑ€åŸá ŸÖŸáÿ±Ÿá‚ÄåŸáÿß
        function setupInitialPosition() {
            // ÿ±ÿÆ‚ÄåŸáÿß
            placePiece(0, 0, 'rook', 'white');
            placePiece(7, 0, 'rook', 'white');
            placePiece(0, 7, 'rook', 'black');
            placePiece(7, 7, 'rook', 'black');
            
            // ÿßÿ≥ÿ®‚ÄåŸáÿß
            placePiece(1, 0, 'knight', 'white');
            placePiece(6, 0, 'knight', 'white');
            placePiece(1, 7, 'knight', 'black');
            placePiece(6, 7, 'knight', 'black');
            
            // ŸÅ€åŸÑ‚ÄåŸáÿß
            placePiece(2, 0, 'bishop', 'white');
            placePiece(5, 0, 'bishop', 'white');
            placePiece(2, 7, 'bishop', 'black');
            placePiece(5, 7, 'bishop', 'black');
            
            // Ÿàÿ≤€åÿ±Ÿáÿß
            placePiece(3, 0, 'queen', 'white');
            placePiece(3, 7, 'queen', 'black');
            
            // ÿ¥ÿßŸá‚ÄåŸáÿß
            placePiece(4, 0, 'king', 'white');
            placePiece(4, 7, 'king', 'black');
            
            // ÿ≥ÿ±ÿ®ÿßÿ≤Ÿáÿß
            for (let col = 0; col < 8; col++) {
                placePiece(col, 1, 'pawn', 'white');
                placePiece(col, 6, 'pawn', 'black');
            }
        }

        function placePiece(col, row, type, color) {
            const square = getSquareElement(row, col);
            square.textContent = pieceSymbols[color][type];
            square.dataset.piece = type;
            square.dataset.color = color;
        }

        function getSquareElement(row, col) {
            const index = (7 - row) * 8 + col;
            return document.getElementById('chessBoard').children[index];
        }

        function handleSquareClick(row, col) {
            if (!gameState.gameActive || gameState.currentPlayer !== gameState.playerColor) return;
            
            const square = getSquareElement(row, col);
            const piece = square.dataset.piece;
            const color = square.dataset.color;
            
            // ÿß⁄Øÿ± ŸÖŸáÿ±Ÿá ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØŸá ÿ®ÿßÿ¥ÿØ
            if (gameState.selectedPiece) {
                const [selectedRow, selectedCol] = gameState.selectedPiece;
                
                // ÿ®ÿ±ÿ±ÿ≥€å ÿ¢€åÿß ÿ≠ÿ±⁄©ÿ™ ŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™
                if (isValidMove(selectedRow, selectedCol, row, col)) {
                    // ÿßŸÜÿ¨ÿßŸÖ ÿ≠ÿ±⁄©ÿ™
                    makeMove(selectedRow, selectedCol, row, col);
                    clearSelection();
                    
                    // ŸÜŸàÿ®ÿ™ AI
                    if (gameState.gameActive) {
                        setTimeout(requestAIMove, 500);
                    }
                } else {
                    clearSelection();
                    if (piece && color === gameState.playerColor) {
                        selectPiece(row, col);
                    }
                }
            } else if (piece && color === gameState.playerColor) {
                selectPiece(row, col);
            }
        }

        function selectPiece(row, col) {
            clearSelection();
            
            gameState.selectedPiece = [row, col];
            const square = getSquareElement(row, col);
            square.classList.add('selected');
            
            // ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ≠ÿ±⁄©ÿßÿ™ ŸÖÿπÿ™ÿ®ÿ± (ÿ≥ÿßÿØŸá)
            gameState.validMoves = calculateValidMoves(row, col);
            highlightValidMoves();
        }

        function calculateValidMoves(row, col) {
            // Ÿæ€åÿßÿØŸá‚Äåÿ≥ÿßÿ≤€å ÿ≥ÿßÿØŸá ÿ≠ÿ±⁄©ÿßÿ™ ŸÖÿπÿ™ÿ®ÿ±
            const moves = [];
            const piece = getSquareElement(row, col).dataset.piece;
            
            // ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ŸÜŸàÿπ ŸÖŸáÿ±Ÿá ÿ≠ÿ±⁄©ÿßÿ™ ŸÖŸÖ⁄©ŸÜ ÿ±ÿß ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ⁄©ŸÜ
            switch (piece) {
                case 'pawn':
                    // ÿ≠ÿ±⁄©ÿ™ Ÿæ€åÿßÿØŸá
                    const direction = gameState.playerColor === 'white' ? 1 : -1;
                    moves.push([row + direction, col]);
                    break;
                case 'knight':
                    // ÿ≠ÿ±⁄©ÿ™ ÿßÿ≥ÿ®
                    const knightMoves = [[2,1], [2,-1], [-2,1], [-2,-1], [1,2], [1,-2], [-1,2], [-1,-2]];
                    knightMoves.forEach(([dr, dc]) => {
                        moves.push([row + dr, col + dc]);
                    });
                    break;
                // ÿ≥ÿß€åÿ± ŸÖŸáÿ±Ÿá‚ÄåŸáÿß...
            }
            
            return moves.filter(([r, c]) => r >= 0 && r < 8 && c >= 0 && c < 8);
        }

        function highlightValidMoves() {
            gameState.validMoves.forEach(([row, col]) => {
                const square = getSquareElement(row, col);
                const targetPiece = square.dataset.piece;
                
                if (targetPiece) {
                    square.classList.add('attack-move');
                } else {
                    square.classList.add('valid-move');
                }
            });
        }

        function clearSelection() {
            // Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ ÿßŸÜÿ™ÿÆÿßÿ® ŸÇÿ®ŸÑ€å
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'valid-move', 'attack-move');
            });
            gameState.selectedPiece = null;
            gameState.validMoves = [];
        }

        function isValidMove(fromRow, fromCol, toRow, toCol) {
            return gameState.validMoves.some(([r, c]) => r === toRow && c === toCol);
        }

        function makeMove(fromRow, fromCol, toRow, toCol) {
            const fromSquare = getSquareElement(fromRow, fromCol);
            const toSquare = getSquareElement(toRow, toCol);
            
            const piece = fromSquare.dataset.piece;
            const color = fromSquare.dataset.color;
            
            // ÿ≠ÿ±⁄©ÿ™ ŸÖŸáÿ±Ÿá
            toSquare.textContent = fromSquare.textContent;
            toSquare.dataset.piece = piece;
            toSquare.dataset.color = color;
            
            fromSquare.textContent = '';
            delete fromSquare.dataset.piece;
            delete fromSquare.dataset.color;
            
            // ÿ´ÿ®ÿ™ ÿ≠ÿ±⁄©ÿ™
            const moveNotation = `${String.fromCharCode(97 + fromCol)}${fromRow + 1}-${String.fromCharCode(97 + toCol)}${toRow + 1}`;
            addMoveToHistory(moveNotation, color);
            
            // ÿ™ÿ∫€å€åÿ± ŸÜŸàÿ®ÿ™
            gameState.currentPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            updateGameStatus();
        }

        function addMoveToHistory(move, color) {
            gameState.moveHistory.push({ move, color });
            const moveList = document.getElementById('moveList');
            const moveItem = document.createElement('div');
            moveItem.className = 'move-item';
            moveItem.innerHTML = `
                <span>${gameState.moveHistory.length}.</span>
                <span>${color === 'white' ? move : '...' + move}</span>
            `;
            moveList.appendChild(moveItem);
            moveList.scrollTop = moveList.scrollHeight;
        }

        function updateGameStatus() {
            document.getElementById('currentPlayer').textContent = 
                `Current: ${gameState.currentPlayer === 'white' ? 'White' : 'Black'}`;
        }

        // ÿ™Ÿàÿßÿ®ÿπ ŸÖÿØ€åÿ±€åÿ™ ÿ®ÿßÿ≤€å
        function newGame() {
            clearSelection();
            initializeBoard();
            gameState.moveHistory = [];
            gameState.currentPlayer = 'white';
            gameState.gameActive = true;
            document.getElementById('moveList').innerHTML = '';
            document.getElementById('gameStatus').textContent = 'Game in progress';
            updateGameStatus();
        }

        function undoMove() {
            // Ÿæ€åÿßÿØŸá‚Äåÿ≥ÿßÿ≤€å undo
            console.log('Undo move');
        }

        function switchSide() {
            gameState.playerColor = gameState.playerColor === 'white' ? 'black' : 'white';
            newGame();
        }

        function showHint() {
            // ÿØÿ±ÿÆŸàÿßÿ≥ÿ™ hint ÿßÿ≤ ÿ≥ÿ±Ÿàÿ±
            console.log('Requesting hint from server');
        }

        function changeDifficulty() {
            const difficulty = document.getElementById('difficulty').value;
            console.log('Difficulty changed to:', difficulty);
        }

        // ÿ™Ÿàÿßÿ®ÿπ ÿßÿ±ÿ™ÿ®ÿßÿ∑ ÿ®ÿß ÿ≥ÿ±Ÿàÿ± ÿßÿ®ÿ±€å
        function requestAIMove() {
            if (!gameState.connected) {
                console.log('Not connected to server');
                return;
            }
            
            // ÿßÿ±ÿ≥ÿßŸÑ Ÿàÿ∂ÿπ€åÿ™ ŸÅÿπŸÑ€å ÿ®Ÿá ÿ≥ÿ±Ÿàÿ± ÿ®ÿ±ÿß€å ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ≠ÿ±⁄©ÿ™
            const gameData = serializeGameState();
            Module.sendMove(gameData);
        }

        function serializeGameState() {
            // ÿ≥ÿ±€åÿßŸÑÿß€åÿ≤ ⁄©ÿ±ÿØŸÜ Ÿàÿ∂ÿπ€åÿ™ ÿ®ÿßÿ≤€å ÿ®ÿ±ÿß€å ÿßÿ±ÿ≥ÿßŸÑ ÿ®Ÿá ÿ≥ÿ±Ÿàÿ±
            return JSON.stringify({
                board: gameState.board,
                currentPlayer: gameState.currentPlayer,
                moveHistory: gameState.moveHistory
            });
        }

        // ÿ™ÿßÿ®ÿπ€å ⁄©Ÿá ÿßÿ≤ ÿ≥ŸÖÿ™ WebAssembly ŸÅÿ±ÿßÿÆŸàÿßŸÜ€å ŸÖ€å‚Äåÿ¥ŸàÿØ
        function updateBoardWithComputerMove(moveData) {
            if (moveData.startsWith('MOVE')) {
                const parts = moveData.split(' ');
                const from = parts[1];
                const to = parts[2];
                
                // ÿ™ÿ¨ÿ≤€åŸá ÿ≠ÿ±⁄©ÿ™ Ÿà ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿµŸÅÿ≠Ÿá
                const fromCol = from.charCodeAt(0) - 97;
                const fromRow = parseInt(from.charAt(1)) - 1;
                const toCol = to.charCodeAt(0) - 97;
                const toRow = parseInt(to.charAt(1)) - 1;
                
                makeMove(fromRow, fromCol, toRow, toCol);
            }
        }

        // ŸÖÿØ€åÿ±€åÿ™ ÿßÿ™ÿµÿßŸÑ WebSocket
        function updateConnectionStatus(connected) {
            gameState.connected = connected;
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                statusDot.className = 'status-dot status-connected';
                statusText.textContent = 'Connected to Cloud Server';
            } else {
                statusDot.className = 'status-dot status-disconnected';
                statusText.textContent = 'Disconnected from Server';
            }
        }

        // ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ÿßŸàŸÑ€åŸá
        window.onload = function() {
            initializeBoard();
            
            // ÿßÿ™ÿµÿßŸÑ ÿ®Ÿá ÿ≥ÿ±Ÿàÿ± ÿßÿ®ÿ±€å
            const serverUrl = 'ws://localhost:9002';
            Module.connectToServer(serverUrl);
            
            // ÿ¥ÿ®€åŸá‚Äåÿ≥ÿßÿ≤€å ÿßÿ™ÿµÿßŸÑ (ÿØÿ± ÿ≠ÿßŸÑÿ™ ŸàÿßŸÇÿπ€å ÿßÿ≤ WebSocket ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äåÿ¥ŸàÿØ)
            setTimeout(() => updateConnectionStatus(true), 2000);
        };
    </script>

    <!-- ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å WebAssembly -->
    <script src="chess_client.js"></script>
</body>
</html>
