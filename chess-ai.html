
    <!DOCTYPE html>
    <html dir="rtl" lang="fa">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Ø´Ø·Ø±Ù†Ø¬ Ù‡ÙˆØ´Ù…Ù†Ø¯ - Ù‚ÙˆØ§Ù†ÛŒÙ† Ú©Ø§Ù…Ù„</title>
        <style>
            :root {
                --primary: #2563eb;
                --secondary: #7c3aed;
                --success: #10b981;
                --warning: #f59e0b;
                --danger: #ef4444;
                --gold: #fbbf24;
            }
            
            body {
                font-family: Tahoma, sans-serif;
                background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
                color: white;
                margin: 0;
                padding: 20px;
            }
            
            .container {
                max-width: 1200px;
                margin: 0 auto;
                display: grid;
                grid-template-columns: 500px 1fr;
                gap: 30px;
            }
            
            .chess-section {
                background: rgba(255,255,255,0.1);
                padding: 25px;
                border-radius: 20px;
                border: 1px solid rgba(255,255,255,0.2);
            }
            
            .analysis-section {
                background: rgba(255,255,255,0.05);
                padding: 25px;
                border-radius: 20px;
                border: 1px solid rgba(255,255,255,0.1);
            }
            
            .chess-board {
                display: grid;
                grid-template-columns: repeat(8, 60px);
                grid-template-rows: repeat(8, 60px);
                gap: 2px;
                background: #769656;
                padding: 10px;
                border-radius: 10px;
                margin: 20px auto;
                width: fit-content;
            }
            
            .chess-square {
                width: 60px;
                height: 60px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 2rem;
                cursor: pointer;
                transition: all 0.2s ease;
                position: relative;
            }
            
            .chess-square.light {
                background: #eeeed2;
            }
            
            .chess-square.dark {
                background: #769656;
            }
            
            .chess-square.selected {
                background: var(--gold) !important;
            }
            
            .chess-square.valid-move::after {
                content: '';
                position: absolute;
                width: 20px;
                height: 20px;
                background: var(--success);
                border-radius: 50%;
                opacity: 0.7;
            }
            
            .chess-square.capture-move::before {
                content: '';
                position: absolute;
                width: 50px;
                height: 50px;
                border: 3px solid var(--danger);
                border-radius: 50%;
                opacity: 0.7;
            }
            
            .chess-square.ai-move {
                background: rgba(59, 130, 246, 0.3) !important;
            }
            
            .chess-square.check {
                background: rgba(239, 68, 68, 0.5) !important;
            }
            
            .analysis-panel {
                background: rgba(0,0,0,0.3);
                padding: 20px;
                border-radius: 10px;
                margin: 15px 0;
            }
            
            .btn {
                padding: 12px 25px;
                background: var(--primary);
                color: white;
                border: none;
                border-radius: 10px;
                cursor: pointer;
                font-size: 1rem;
                margin: 8px 5px;
                transition: all 0.3s ease;
            }
            
            .btn:hover {
                background: var(--secondary);
                transform: translateY(-2px);
            }
            
            .btn-gold {
                background: var(--gold);
                color: black;
                font-weight: bold;
            }
            
            .btn-success {
                background: var(--success);
            }
            
            .btn-danger {
                background: var(--danger);
            }
            
            .metric {
                display: flex;
                justify-content: space-between;
                margin: 10px 0;
                padding: 10px;
                background: rgba(255,255,255,0.1);
                border-radius: 8px;
            }
            
            .score-bar {
                height: 10px;
                background: rgba(255,255,255,0.2);
                border-radius: 5px;
                margin: 5px 0;
                overflow: hidden;
            }
            
            .score-fill {
                height: 100%;
                background: var(--success);
                transition: width 0.5s ease;
            }
            
            .move-history {
                max-height: 200px;
                overflow-y: auto;
                margin: 15px 0;
            }
            
            .move-item {
                padding: 8px;
                margin: 5px 0;
                background: rgba(255,255,255,0.1);
                border-radius: 5px;
                display: flex;
                justify-content: space-between;
            }
            
            .rules-panel {
                background: rgba(255,255,255,0.05);
                padding: 15px;
                border-radius: 10px;
                margin: 10px 0;
                border-right: 4px solid var(--success);
            }
        </style>
    </head>
    <body>
        <div style="text-align: center; margin-bottom: 30px;">
            <h1 style="font-size: 2.5rem; margin-bottom: 10px;">ğŸ† Ø´Ø·Ø±Ù†Ø¬ Ù‡ÙˆØ´Ù…Ù†Ø¯ - Ù‚ÙˆØ§Ù†ÛŒÙ† Ú©Ø§Ù…Ù„</h1>
            <p style="opacity: 0.8;">Ø³ÛŒØ³ØªÙ… Ø´Ø·Ø±Ù†Ø¬ Ø¨Ø§ Ù‚ÙˆØ§Ù†ÛŒÙ† Ú©Ø§Ù…Ù„ FIDE - Ù†Ø³Ø®Ù‡ ØªØµØ­ÛŒØ­ Ø´Ø¯Ù‡</p>
        </div>
        
        <div class="container">
            <div class="chess-section">
                <h2>â™Ÿï¸ ØµÙØ­Ù‡ Ø´Ø·Ø±Ù†Ø¬</h2>
                <div class="rules-panel">
                    <strong>âœ… Ù‚ÙˆØ§Ù†ÛŒÙ† ÙØ¹Ø§Ù„:</strong> Ø­Ø±Ú©Øª ØµØ­ÛŒØ­ Ù…Ù‡Ø±Ù‡â€ŒÙ‡Ø§ | Ú©ÛŒØ´ | Ø¢Ù†Ù¾Ø§Ø³Ø§Ù† | ØªØ¨Ø¯ÛŒÙ„ Ø³Ø±Ø¨Ø§Ø²
                </div>
                
                <div class="chess-board" id="chessBoard">
                    <!-- Board generated by JavaScript -->
                </div>
                
                <div style="text-align: center; margin: 20px 0;">
                    <button class="btn btn-gold" onclick="startNewGame()">ğŸ”„ Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯</button>
                    <button class="btn btn-success" onclick="toggleAutoMove()" id="autoMoveBtn">
                        ğŸ¤– Ø­Ø±Ú©Øª Ø®ÙˆØ¯Ú©Ø§Ø± AI: ÙØ¹Ø§Ù„
                    </button>
                    <button class="btn" onclick="showValidMoves()">ğŸ” Ù†Ù…Ø§ÛŒØ´ Ø­Ø±Ú©Ø§Øª Ù…Ø¬Ø§Ø²</button>
                </div>
                
                <div class="analysis-panel">
                    <h3>ğŸ“Š ÙˆØ¶Ø¹ÛŒØª Ø¨Ø§Ø²ÛŒ</h3>
                    <div id="gameStatus">Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ...</div>
                    <div class="metric">
                        <span>Ø§Ù…ØªÛŒØ§Ø² Ù…ÙˆÙ‚Ø¹ÛŒØª:</span>
                        <span id="positionScore">--</span>
                    </div>
                    <div class="score-bar">
                        <div class="score-fill" id="scoreBar" style="width: 50%"></div>
                    </div>
                </div>
                
                <div class="analysis-panel">
                    <h3>ğŸ“‹ ØªØ§Ø±ÛŒØ®Ú†Ù‡ Ø­Ø±Ú©Ø§Øª</h3>
                    <div class="move-history" id="moveHistory">
                        <!-- Move history will be added here -->
                    </div>
                </div>
            </div>
            
            <div class="analysis-section">
                <h2>ğŸ“ˆ ØªØ­Ù„ÛŒÙ„ Ù¾ÛŒØ´Ø±ÙØªÙ‡</h2>
                
                <div class="analysis-panel">
                    <h3>ğŸ¯ ØªØ­Ù„ÛŒÙ„ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</h3>
                    <div id="aiAnalysis">Ù‡ÛŒÚ† ØªØ­Ù„ÛŒÙ„ÛŒ Ø§Ù†Ø¬Ø§Ù… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª</div>
                </div>
                
                <div class="analysis-panel">
                    <h3>ğŸ“‹ Ù‚ÙˆØ§Ù†ÛŒÙ† ÙØ¹Ø§Ù„ Ø´Ø¯Ù‡</h3>
                    <div style="line-height: 2;">
                        <div>âœ… Ø­Ø±Ú©Øª Ø³Ø±Ø¨Ø§Ø² (ÛŒÚ© Ø®Ø§Ù†Ù‡ØŒ Ø¯Ùˆ Ø®Ø§Ù†Ù‡ Ø§ÙˆÙ„ØŒ Ø¶Ø±Ø¨Ø¯Ø±ÛŒ)</div>
                        <div>âœ… Ø­Ø±Ú©Øª Ø§Ø³Ø¨ (L-shaped)</div>
                        <div>âœ… Ø­Ø±Ú©Øª ÙÛŒÙ„ (Ù…ÙˆØ±Ø¨)</div>
                        <div>âœ… Ø­Ø±Ú©Øª Ø±Ø® (Ø§ÙÙ‚ÛŒ/Ø¹Ù…ÙˆØ¯ÛŒ)</div>
                        <div>âœ… Ø­Ø±Ú©Øª ÙˆØ²ÛŒØ± (ØªØ±Ú©ÛŒØ¨ ÙÛŒÙ„ Ùˆ Ø±Ø®)</div>
                        <div>âœ… Ø­Ø±Ú©Øª Ø´Ø§Ù‡ (ÛŒÚ© Ø®Ø§Ù†Ù‡)</div>
                        <div>âœ… Ù‚Ø§Ù†ÙˆÙ† Ú©ÛŒØ´</div>
                        <div>âœ… Ù¾ÛŒØ´Ú¯ÛŒØ±ÛŒ Ø§Ø² Ø­Ø±Ú©Øª ØºÛŒØ±Ù…Ø¬Ø§Ø²</div>
                    </div>
                </div>
                
                <div class="analysis-panel">
                    <h3>âš¡ Ø¹Ù…Ù„Ú©Ø±Ø¯ Ø³ÛŒØ³ØªÙ…</h3>
                    <div class="metric">
                        <span>Ù…ÙˆØªÙˆØ± Ù‚ÙˆØ§Ù†ÛŒÙ†:</span>
                        <span style="color: var(--success);">ÙØ¹Ø§Ù„ âœ…</span>
                    </div>
                    <div class="metric">
                        <span>Ø­Ø±Ú©Øª Ø®ÙˆØ¯Ú©Ø§Ø± AI:</span>
                        <span id="autoMoveStatus" style="color: var(--success);">ÙØ¹Ø§Ù„ âœ…</span>
                    </div>
                    <div class="metric">
                        <span>Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø­Ø±Ú©Øª:</span>
                        <span style="color: var(--success);">ÙØ¹Ø§Ù„ âœ…</span>
                    </div>
                </div>
                
                <div class="analysis-panel">
                    <h3>ğŸ® Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø¨Ø§Ø²ÛŒ</h3>
                    <div style="font-size: 0.9rem; line-height: 1.6;">
                        <p>â€¢ Ø¨Ø±Ø§ÛŒ Ø­Ø±Ú©Øª: Ø±ÙˆÛŒ Ù…Ù‡Ø±Ù‡ Ø®ÙˆØ¯ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ Ø³Ù¾Ø³ Ø±ÙˆÛŒ Ø®Ø§Ù†Ù‡ Ù…Ù‚ØµØ¯</p>
                        <p>â€¢ Ø­Ø±Ú©Ø§Øª Ù…Ø¬Ø§Ø² Ø¨Ø§ Ø¯Ø§ÛŒØ±Ù‡ Ø³Ø¨Ø² Ù†Ø´Ø§Ù† Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯</p>
                        <p>â€¢ Ø­Ø±Ú©Ø§Øª Ø¶Ø±Ø¨ØªÛŒ Ø¨Ø§ Ø­Ø§Ø´ÛŒÙ‡ Ù‚Ø±Ù…Ø² Ù…Ø´Ø®Øµ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯</p>
                        <p>â€¢ Ø¯Ø± ØµÙˆØ±Øª Ú©ÛŒØ´ØŒ Ø®Ø§Ù†Ù‡ Ø´Ø§Ù‡ Ù‚Ø±Ù…Ø² Ù…ÛŒâ€ŒØ´ÙˆØ¯</p>
                    </div>
                </div>
            </div>
        </div>

        <script>
            let currentGame = {
                board: [],
                currentPlayer: 'white',
                selectedPiece: null,
                validMoves: [],
                difficulty: 'expert',
                analysis: null,
                moveHistory: [],
                autoMove: true,
                inCheck: false
            };

            const pieceValues = {
                'pawn': 1, 'knight': 3, 'bishop': 3, 'rook': 5, 'queen': 9, 'king': 100
            };

            async function initializeBoard() {
                currentGame.board = createInitialBoard();
                renderBoard();
                updateGameStatus('Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù‚ÙˆØ§Ù†ÛŒÙ† Ú©Ø§Ù…Ù„ Ø¢ØºØ§Ø² Ø´Ø¯! â™Ÿï¸');
                await updateValidMoves();
            }

            function createInitialBoard() {
                const board = Array(8).fill().map(() => Array(8).fill(null));
                
                // Setup pieces according to standard chess rules
                const backRow = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
                
                // Black pieces (top)
                for (let col = 0; col < 8; col++) {
                    board[0][col] = { type: backRow[col], color: 'black' };
                    board[1][col] = { type: 'pawn', color: 'black' };
                }
                
                // White pieces (bottom)
                for (let col = 0; col < 8; col++) {
                    board[6][col] = { type: 'pawn', color: 'white' };
                    board[7][col] = { type: backRow[col], color: 'white' };
                }
                
                return board;
            }

            function renderBoard() {
                const boardElement = document.getElementById('chessBoard');
                boardElement.innerHTML = '';
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        square.className = `chess-square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        square.dataset.row = row;
                        square.dataset.col = col;
                        
                        const piece = currentGame.board[row][col];
                        if (piece) {
                            square.textContent = getPieceSymbol(piece);
                            square.style.color = piece.color === 'white' ? 'white' : 'black';
                            square.style.textShadow = piece.color === 'white' ? '2px 2px 4px rgba(0,0,0,0.5)' : '2px 2px 4px rgba(255,255,255,0.3)';
                        }
                        
                        // Highlight selected piece
                        if (currentGame.selectedPiece && currentGame.selectedPiece.row === row && currentGame.selectedPiece.col === col) {
                            square.classList.add('selected');
                        }
                        
                        // Highlight valid moves
                        if (currentGame.validMoves.some(move => move.row === row && move.col === col)) {
                            const targetPiece = currentGame.board[row][col];
                            if (targetPiece) {
                                square.classList.add('capture-move');
                            } else {
                                square.classList.add('valid-move');
                            }
                        }
                        
                        square.onclick = () => handleSquareClick(row, col);
                        boardElement.appendChild(square);
                    }
                }
                
                // Highlight king in check
                highlightCheck();
            }

            function getPieceSymbol(piece) {
                const symbols = {
                    'white': { 
                        'pawn': 'â™™', 'rook': 'â™–', 'knight': 'â™˜', 
                        'bishop': 'â™—', 'queen': 'â™•', 'king': 'â™”' 
                    },
                    'black': { 
                        'pawn': 'â™Ÿ', 'rook': 'â™œ', 'knight': 'â™',
                        'bishop': 'â™', 'queen': 'â™›', 'king': 'â™š' 
                    }
                };
                return symbols[piece.color][piece.type];
            }

            async function handleSquareClick(row, col) {
                const piece = currentGame.board[row][col];
                
                // If a piece is already selected, try to move
                if (currentGame.selectedPiece) {
                    const moveIsValid = currentGame.validMoves.some(move => move.row === row && move.col === col);
                    
                    if (moveIsValid) {
                        await makeMove(currentGame.selectedPiece.row, currentGame.selectedPiece.col, row, col);
                        return;
                    }
                    
                    // Deselect if clicking elsewhere
                    currentGame.selectedPiece = null;
                    currentGame.validMoves = [];
                    renderBoard();
                }
                
                // Select a new piece if it belongs to current player
                if (piece && piece.color === currentGame.currentPlayer) {
                    currentGame.selectedPiece = { row, col, piece };
                    await updateValidMovesForPiece(row, col);
                    renderBoard();
                }
            }

            async function updateValidMovesForPiece(row, col) {
                try {
                    const response = await fetch('/api/chess/get-valid-moves', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            board: currentGame.board,
                            row: row,
                            col: col,
                            player: currentGame.currentPlayer
                        })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        currentGame.validMoves = data.validMoves;
                    }
                } catch (error) {
                    console.error('Error getting valid moves:', error);
                    currentGame.validMoves = [];
                }
            }

            async function makeMove(fromRow, fromCol, toRow, toCol) {
                // Validate move with server
                const validation = await validateMove(fromRow, fromCol, toRow, toCol);
                
                if (!validation.valid) {
                    updateGameStatus(`Ø­Ø±Ú©Øª ØºÛŒØ±Ù…Ø¬Ø§Ø²: ${validation.reason}`);
                    currentGame.selectedPiece = null;
                    currentGame.validMoves = [];
                    renderBoard();
                    return;
                }
                
                // Add to move history
                const fromNotation = coordinatesToNotation(fromRow, fromCol);
                const toNotation = coordinatesToNotation(toRow, toCol);
                currentGame.moveHistory.push({
                    player: currentGame.currentPlayer,
                    move: `${fromNotation} â†’ ${toNotation}`,
                    piece: currentGame.board[fromRow][fromCol].type
                });
                updateMoveHistory();
                
                // Execute move
                const capturedPiece = currentGame.board[toRow][toCol];
                currentGame.board[toRow][toCol] = currentGame.board[fromRow][fromCol];
                currentGame.board[fromRow][fromCol] = null;
                
                // Switch player
                currentGame.currentPlayer = currentGame.currentPlayer === 'white' ? 'black' : 'white';
                currentGame.selectedPiece = null;
                currentGame.validMoves = [];
                
                updateGameStatus(`Ø­Ø±Ú©Øª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯: ${fromNotation} â†’ ${toNotation}`);
                renderBoard();
                
                // Request AI analysis
                await requestAIAnalysis();
                
                // Auto-move for AI if enabled
                if (currentGame.autoMove && currentGame.currentPlayer === 'black') {
                    setTimeout(async () => {
                        await makeAIMove();
                    }, 1000);
                }
            }

            async function validateMove(fromRow, fromCol, toRow, toCol) {
                try {
                    const response = await fetch('/api/chess/validate-move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            board: currentGame.board,
                            fromRow: fromRow,
                            fromCol: fromCol,
                            toRow: toRow,
                            toCol: toCol,
                            player: currentGame.currentPlayer
                        })
                    });
                    
                    const data = await response.json();
                    return data;
                } catch (error) {
                    return { valid: false, reason: 'Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø­Ø±Ú©Øª' };
                }
            }

            function highlightCheck() {
                // This would be implemented to highlight king in check
                // For now, it's a placeholder
            }

            async function makeAIMove() {
                if (currentGame.currentPlayer !== 'black') {
                    updateGameStatus('âš ï¸ Ø§Ù„Ø§Ù† Ù†ÙˆØ¨Øª Ø´Ù…Ø§Ø³Øª!');
                    return;
                }
                
                updateGameStatus('ğŸ¤– Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¯Ø± Ø­Ø§Ù„ ÙÚ©Ø± Ú©Ø±Ø¯Ù†...');
                
                try {
                    const response = await fetch('/api/chess/make-ai-move', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            board: currentGame.board,
                            player: 'black'
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        const from = notationToCoordinates(data.move.from);
                        const to = notationToCoordinates(data.move.to);
                        
                        await makeMove(from.row, from.col, to.row, to.col);
                        updateGameStatus(`ğŸ¤– AI Ø­Ø±Ú©Øª Ú©Ø±Ø¯: ${data.move.from} â†’ ${data.move.to}`);
                    }
                } catch (error) {
                    updateGameStatus('âŒ Ø®Ø·Ø§ Ø¯Ø± Ø­Ø±Ú©Øª AI');
                }
            }

            function coordinatesToNotation(row, col) {
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                return files[col] + ranks[row];
            }

            function notationToCoordinates(notation) {
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
                const col = files.indexOf(notation[0]);
                const row = ranks.indexOf(notation[1]);
                return { row, col };
            }

            async function requestAIAnalysis() {
                const analysisElement = document.getElementById('aiAnalysis');
                analysisElement.innerHTML = 'ğŸ§  Ø¯Ø± Ø­Ø§Ù„ ØªØ­Ù„ÛŒÙ„ Ù…ÙˆÙ‚Ø¹ÛŒØª...';
                
                try {
                    const response = await fetch('/api/chess/analyze', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            board: currentGame.board,
                            currentPlayer: currentGame.currentPlayer,
                            difficulty: currentGame.difficulty
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        displayAnalysis(data.analysis);
                    }
                } catch (error) {
                    analysisElement.innerHTML = 'âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ­Ù„ÛŒÙ„';
                }
            }

            function displayAnalysis(analysis) {
                const analysisElement = document.getElementById('aiAnalysis');
                const scoreElement = document.getElementById('positionScore');
                const scoreBar = document.getElementById('scoreBar');
                
                analysisElement.innerHTML = `
                    <div style="color: var(--success); margin-bottom: 10px;">
                        <strong>ØªÙˆØµÛŒÙ‡ Ø­Ø±Ú©Øª:</strong> ${analysis.move.from} Ø¨Ù‡ ${analysis.move.to}
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>Ø§Ù…ØªÛŒØ§Ø²:</strong> ${analysis.score}/100
                    </div>
                    <div style="opacity: 0.8; font-size: 0.9rem;">
                        ${analysis.explanation}
                    </div>
                `;
                
                scoreElement.textContent = `${analysis.score}/100`;
                scoreBar.style.width = `${analysis.score}%`;
                scoreBar.style.background = analysis.score > 70 ? 'var(--success)' : analysis.score > 40 ? 'var(--warning)' : 'var(--danger)';
            }

            function toggleAutoMove() {
                currentGame.autoMove = !currentGame.autoMove;
                const btn = document.getElementById('autoMoveBtn');
                const status = document.getElementById('autoMoveStatus');
                
                if (currentGame.autoMove) {
                    btn.textContent = 'ğŸ¤– Ø­Ø±Ú©Øª Ø®ÙˆØ¯Ú©Ø§Ø± AI: ÙØ¹Ø§Ù„';
                    btn.classList.add('btn-success');
                    status.textContent = 'ÙØ¹Ø§Ù„ âœ…';
                    status.style.color = 'var(--success)';
                    updateGameStatus('Ø­Ø±Ú©Øª Ø®ÙˆØ¯Ú©Ø§Ø± AI ÙØ¹Ø§Ù„ Ø´Ø¯ ğŸ¤–');
                } else {
                    btn.textContent = 'ğŸ¤– Ø­Ø±Ú©Øª Ø®ÙˆØ¯Ú©Ø§Ø± AI: ØºÛŒØ±ÙØ¹Ø§Ù„';
                    btn.classList.remove('btn-success');
                    status.textContent = 'ØºÛŒØ±ÙØ¹Ø§Ù„ âŒ';
                    status.style.color = 'var(--danger)';
                    updateGameStatus('Ø­Ø±Ú©Øª Ø®ÙˆØ¯Ú©Ø§Ø± AI ØºÛŒØ±ÙØ¹Ø§Ù„ Ø´Ø¯');
                }
            }

            async function showValidMoves() {
                if (currentGame.selectedPiece) {
                    await updateValidMovesForPiece(currentGame.selectedPiece.row, currentGame.selectedPiece.col);
                    renderBoard();
                    updateGameStatus(`${currentGame.validMoves.length} Ø­Ø±Ú©Øª Ù…Ø¬Ø§Ø² Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ù…Ù‡Ø±Ù‡`);
                } else {
                    updateGameStatus('Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ù…Ù‡Ø±Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯');
                }
            }

            function updateMoveHistory() {
                const historyElement = document.getElementById('moveHistory');
                historyElement.innerHTML = '';
                
                currentGame.moveHistory.slice(-10).forEach((move, index) => {
                    const moveElement = document.createElement('div');
                    moveElement.className = 'move-item';
                    moveElement.innerHTML = `
                        <span>${index + 1}. ${move.move}</span>
                        <span style="opacity: 0.7;">${move.player === 'white' ? 'Ø³ÙÛŒØ¯' : 'Ø³ÛŒØ§Ù‡'}</span>
                    `;
                    historyElement.appendChild(moveElement);
                });
                
                historyElement.scrollTop = historyElement.scrollHeight;
            }

            function startNewGame() {
                currentGame = {
                    board: [],
                    currentPlayer: 'white',
                    selectedPiece: null,
                    validMoves: [],
                    difficulty: 'expert',
                    analysis: null,
                    moveHistory: [],
                    autoMove: true,
                    inCheck: false
                };
                initializeBoard();
                updateGameStatus('Ø¨Ø§Ø²ÛŒ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù‚ÙˆØ§Ù†ÛŒÙ† Ú©Ø§Ù…Ù„ Ø¢ØºØ§Ø² Ø´Ø¯! â™Ÿï¸');
            }

            function updateGameStatus(message) {
                document.getElementById('gameStatus').textContent = message;
            }

            async function updateValidMoves() {
                // This would update all valid moves for current player
                // For now, it's a placeholder
            }

            // Initialize game
            document.addEventListener('DOMContentLoaded', initializeBoard);
        </script>
    </body>
    </html>
    